#### **1. Что такое S3DIS и для чего он используется?**

**S3DIS** — это датасет для семантической сегментации 3D-облаков точек **внутренних помещений** (офисы, аудитории, коридоры). Он был собран в зданиях Стэнфордского университета с помощью **Matterport Kinect-сканера**.  
**Используется** для:
- обучения и тестирования моделей 3D-семантической сегментации (PointNet, PointNet++, KPConv и др.),
- исследования восприятия индоор-сред роботами и AR/VR-системами.

---

#### **2. Какие типы данных содержит S3DIS?**
Каждая сцена содержит:
- **Координаты точек**: `(x, y, z)` — в метрах, относительно сканера,
- **Цвет (RGB)**: `(r, g, b)` — нормализованный в `[0, 1]` или `[0, 255]` (зависит от предобработки),
- **Нормали поверхности (опционально)**: `(nx, ny, nz)` — редко используются, но могут быть вычислены,
- **Семантические метки**: целые числа (0–12), соответствующие 13 классам.
 Формат хранения — `.txt` (ASCII) или предобработанные `.npy`.

---

#### **3. Сколько пространств (Areas) включает датасет?**

**6 зон (Areas)**:

- `Area_1`, `Area_2`, `Area_3`, `Area_4`, `Area_5`, `Area_6`.  
    Каждая зона — отдельное здание/этаж с множеством комнат (всего ~271 комната).  
    Часто для кросс-валидации используют **leave-one-area-out**: обучение на 5 зонах, тест на 6-й.

---

#### **4. Что представляют собой строки в `.txt` файлах S3DIS? Опишите формат.**

Каждая строка соответствует **одной точке** и содержит **6 или 7 чисел** через пробел:
- `x, y, z` — 3D-координаты (float),
- `r, g, b` — цвет (float в `[0, 1]` или int в `[0, 255]` — в оригинале — `[0, 1]`),
- `label` — **только в размеченных файлах** (например, `*_annotations.txt`), целое число от 0 до 12.

 ```
 x y z r g b [label]
 3.21 1.45 -0.87 0.72 0.65 0.58 2
 ```
 
→ точка в координатах (3.21, 1.45, –0.87), цвет (184, 166, 148), класс `2` = **wall**.

>  В "сырых" сканах (`*.txt`) метки отсутствуют; разметка хранится в `Annotations/` как отдельные файлы на объект/комнату.

---

#### **5. Какие задачи машинного обучения можно решать с помощью S3DIS?**

- **Семантическая сегментация** (основная задача): каждая точка → класс,
- **Инстанс-сегментация**: каждая точка → (класс, ID объекта),
- **3D детекция объектов**: регрессия 3D-боксов по облаку,
- **Обучение без учителя / самообучение**: contrastive learning, masked autoencoding (например, Point-BERT),
- **Мультизадачное обучение**: сегментация + нормали + суперразрешение.

---

#### **6. Какие классы (объекты) включены в разметку S3DIS? Приведите примеры.**

**13 классов** (в порядке индекса):

|№|Класс|Примеры|
|---|---|---|
|0|ceiling|Потолочные плиты, люминесцентные панели|
|1|floor|Паркет, плитка, ковры|
|2|wall|Бетонные/гипсокартонные стены, панели|
|3|beam|Металлические/бетонные балки на потолке|
|4|column|Колонны, опоры|
|5|window|Оконные рамы, стёкла (часто как единый объект)|
|6|door|Дверные полотна и коробки|
|7|table|Столы, конференц-столы, тумбы|
|8|chair|Стулья, кресла, табуреты|
|9|sofa|Диваны, кушетки|
|10|bookcase|Книжные шкафы, стеллажи|
|11|board|Доски (маркерные, меловые, проекционные)|
|12|clutter|"Мусор": провода, растения, кофейные чашки, сумки и др. мелкие объекты|

>  `clutter` — "catch-all" класс для редких/нестандартных объектов.

---

### **Вопросы по подготовке данных**

#### **7. Какие признаки можно извлекать из данных S3DIS для обучения модели?**

- **Базовые**: `[x, y, z, r, g, b]` — 6D вход (минимум для PointNet++),
- **Расширенные**:
    - Нормали `(nx, ny, nz)` (вычисляются через PCA в окрестности),
    - Относительные координаты в блоке/комнате (например, `x_local = x – x_room_center`),
    - Признаки формы: кривизна, плотность, eigenvalues локального облака,
    - Высота над полом (`z – z_floor`),
    - Бинарные флаги: близость к стене/потолку (через RANSAC или ground truth).

>  В большинстве работ используют только **6D (xyz + rgb)**.

---

#### **8. Что такое нормализация координат, и зачем она нужна при подготовке 3D данных?**

**Нормализация координат** — приведение `(x, y, z)` к сопоставимому масштабу и центру.

**Типичные методы**:

- **Центрирование по блоку**: `xyz -= np.mean(xyz, axis=0)`,
- **Масштабирование**:
    - `xyz /= np.max(np.linalg.norm(xyz, axis=1))` → [-1, 1],
    - или `xyz /= np.std(xyz)` → std = 1.

**Зачем нужно**:

- Сети чувствительны к абсолютному масштабу → без нормализации сходятся медленно или не сходятся,
- Ускоряет обучение (градиенты стабильнее),
- Позволяет использовать одинаковые гиперпараметры (радиусы группировки, learning rate) для разных сцен.

---

#### **9. Почему важно сохранять данные в формате NumPy (`.npy`, `.npz`) при работе с ML-моделями?**

-  **Быстрая загрузка**: бинарный формат → в 10–100× быстрее, чем чтение `.txt`,
-  **Экономия места**: `.npy` компактнее ASCII; `.npz` (и особенно `compressed`) — ещё лучше,
-  **Совместимость**: `np.load()` → сразу `ndarray`, который можно передавать в `torch.from_numpy()`,
-  **Гибкость**: можно сохранять словари (`np.savez('data.npz', xyz=..., rgb=..., label=...)`),
-  **Воспроизводимость**: фиксированный порядок, тип данных (`dtype`), форма.

---

#### **10. Как разделить данные на входные признаки и метки классов?**

Пусть `data` — массив `(N, 7)` (если есть метки) или `(N, 6)` (если нет).

```python
# Если данные в формате: x y z r g b [label]
if data.shape[1] == 7:
    points = data[:, :6]      # (N, 6) — xyz + rgb
    labels = data[:, 6].astype(np.int64)  # (N,)
elif data.shape[1] == 6:
    points = data             # (N, 6)
    labels = None             # нет разметки
    
#pytorch:
points = torch.from_numpy(points).float()
labels = torch.from_numpy(labels).long()
```


---

#### **11. Чем отличается `np.save()` от `np.savez()` и `np.savez_compressed()`?**

|Функция|Формат|Особенности|Когда использовать|
|---|---|---|---|
|`np.save('file.npy', arr)`|Одиночный массив|—|Сохранение одного тензора (например, `block_points.npy`)|
|`np.savez('file.npz', arr1=arr1, arr2=arr2)`|ZIP-архив без сжатия|Хранит несколько массивов по именам|Сохранение `xyz`, `rgb`, `label` отдельно|
|`np.savez_compressed('file.npz', ...)`|ZIP + deflate (gzip)|Меньше размер, но медленнее запись/чтение|Экономия диска при большом количестве блоков|

 Расширение `.npz` — всегда архив (даже без `_compressed`), `.npy` — один массив.

---

#### **12. Какие потенциальные проблемы могут возникнуть при чтении и обработке S3DIS?**

| Проблема                                            | Описание                                                                    | Решение                                                             |
| --------------------------------------------------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------- |
| **Разный формат цвета**                             | В одних файлах `rgb ∈ [0, 1]`, в других — `[0, 255]`                        | Проверить максимум: `if rgb.max() > 1.0: rgb /= 255.0`              |
| **Отсутствие меток в "сырых" файлах**               | `.txt` в корне — без `label`; разметка в `Annotations/` как отдельные файлы | Склеить аннотации по комнатам (скрипт от авторов S3DIS)             |
| **Несовпадение масштабов между зонами**             | Area_5 может быть в 2× больше Area_1                                        | Нормализовывать **по комнате или блоку**, а не по всей зоне         |
| **Дубликаты точек**                                 | Из-за наложения сканов с разных ракурсов                                    | Удалить через `np.unique(points, axis=0)` или voxel даунсэмплинг    |
| **Класс `clutter` доминирует в некоторых комнатах** | Искажает баланс классов                                                     | Использовать weighted loss или undersampling                        |
| **Большой объём данных**                            | Полный датасет ~3 ГБ, но разбит на 1000+ файлов → медленное I/O             | Предобработать → сохранить в `.npz` блоками (4096 точек)            |
| **Аннотации "утекают" за границы объектов**         | Человек стоял у стола — часть точек стола помечена как `clutter`            | Визуальная проверка, post-processing (CRF, majority voting в блоке) |
